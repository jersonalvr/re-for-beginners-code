\subsection{\NonOptimizingKeilVI (\ARMMode)}

\RU{Для начала скомпилируем наш пример в Keil}\EN{Let's start by compiling our example in Keil}\ES{Para empezar, compilamos nuestro ejemplo en Keil}:

\begin{lstlisting}
armcc.exe --arm --c90 -O0 1.c 
\end{lstlisting}

\index{\IntelSyntax}
\RU{Компилятор \IT{armcc} генерирует листинг на ассемблере в формате Intel.}
\EN{The \IT{armcc} compiler produces assembly listings in Intel-syntax} 
\ES{El compilador \IT{armcc} produce listados en ensamblador con sintaxis Intel} 
\RU{Этот листинг содержит некоторые высокоуровневые макросы, связанные с ARM}%
\EN{but it has high-level ARM-processor related macros}\ES{, pero incluye macros de alto nivel relacionados con ARM}\footnote{
\RU{например, он показывает инструкции \PUSH/\POP, отсутствующие в режиме ARM}
\EN{e.g. ARM mode lacks \PUSH/\POP instructions}\ES{p. ej., muestra instrucciones \PUSH/\POP, ausentes en el modo ARM}}, 
\RU{а нам важнее увидеть инструкции \q{как есть}, так что посмотрим скомпилированный результат в \IDA.}
\EN{but it is more important for us to see the instructions \q{as is} so let's see the compiled result in \IDA.}
\ES{pero nos importa más ver las instrucciones tal cual, así que veamos el resultado compilado en \IDA.}

\begin{lstlisting}[caption=\NonOptimizingKeilVI (\ARMMode) \IDA]
.text:00000000             main
.text:00000000 10 40 2D E9    STMFD   SP!, {R4,LR}
.text:00000004 1E 0E 8F E2    ADR     R0, aHelloWorld ; "hello, world"
.text:00000008 15 19 00 EB    BL      __2printf
.text:0000000C 00 00 A0 E3    MOV     R0, #0
.text:00000010 10 80 BD E8    LDMFD   SP!, {R4,PC}

.text:000001EC 68 65 6C 6C+aHelloWorld  DCB "hello, world",0    ; DATA XREF: main+4
\end{lstlisting}

\RU{В вышеприведённом примере можно легко увидеть, что каждая инструкция имеет размер 4 байта.}
\EN{In the example, we can easily see each instruction has a size of 4 bytes.}
\ES{En el ejemplo anterior se ve fácilmente que cada instrucción mide 4 bytes.}
\RU{Действительно, ведь мы же компилировали наш код для режима ARM, а не Thumb.}
\EN{Indeed, we compiled our code for ARM mode, not for Thumb.}
\ES{Efectivamente, compilamos el código para modo ARM, no Thumb.}

\index{ARM!\Instructions!STMFD}
\index{ARM!\Instructions!POP}
\RU{Самая первая инструкция}\EN{The very first instruction}\ES{La primera instrucción}, \TT{STMFD SP!, \{R4,LR\}}\footnote{\ac{STMFD}}, 
\RU{работает как инструкция}\EN{works as an x86}\ES{funciona como una} \PUSH \RU{в x86}\EN{instruction}\ES{ de x86},
\RU{записывая значения двух регистров}\EN{writing the values of two registers}\ES{escribiendo los valores de dos registros}
(\Reg{4} \AndENRU \ac{LR}) \RU{в стек}\EN{into the stack}\ES{ en la pila}.
\RU{Действительно, в выдаваемом листинге на ассемблере компилятор \IT{armcc} для упрощения указывает здесь инструкцию}
\EN{Indeed, in the output listing from the \IT{armcc} compiler, for the sake of simplification, 
actually shows the} \TT{PUSH \{r4,lr\}}\EN{ instruction}\ES{ de hecho muestra la instrucción}.
\RU{Но это не совсем точно, инструкция \PUSH доступна только в режиме Thumb, поэтому,
во избежание путаницы, я предложил работать в \IDA}%
\EN{But that is not quite precise. The \PUSH instruction is only available in Thumb mode.
So, to make things less confusing, we're doing this in \IDA}.
\ES{Pero eso no es del todo preciso: \PUSH solo está disponible en modo Thumb; para evitar confusiones, lo veremos en \IDA}.

\RU{Итак, эта инструкция уменьшает \ac{SP}, чтобы он указывал на место в стеке, свободное для записи
новых значений, затем записывает значения регистров \Reg{4} и \ac{LR} 
по адресу в памяти, на который указывает измененный регистр \ac{SP}}%
\EN{This instruction \glspl{decrement} first the \ac{SP} so it points to the place in the stack
that is free for new entries, then it saves the values of the \Reg{4} and \ac{LR} registers at the address
stored in the modified \ac{SP}}\ES{Esta instrucción primero \glspl{decrement} el \ac{SP} para que apunte a un lugar libre de la pila y después guarda los valores de \Reg{4} y \ac{LR} en la dirección indicada por el \ac{SP} modificado}.

\RU{Эта инструкция, как и инструкция \PUSH в режиме Thumb, может сохранить в стеке одновременно несколько значений регистров, что может быть очень удобно}%
\EN{This instruction (like the \PUSH instruction in Thumb mode) is able to save several register values at once which can be very useful}. 
\ES{Esta instrucción (como \PUSH en modo Thumb) puede guardar varios registros a la vez, lo cual puede ser muy útil}. 
\RU{Кстати, такого в x86 нет}\EN{By the way, this has no equivalent in x86}.\ES{Por cierto, esto no existe en x86}.
\RU{Также следует заметить, что \TT{STMFD}~--- генерализация инструкции \PUSH (то есть расширяет её возможности), потому что может работать с любым регистром, а не только с \ac{SP}.}
\EN{It can also be noted that the \TT{STMFD} instruction is a generalization 
of the \PUSH instruction (extending its features), since it can work with any register, not just with \ac{SP}.}
\ES{También puede notarse que \TT{STMFD} es una generalización de \PUSH (amplía sus capacidades), porque puede trabajar con cualquier registro y no solo con \ac{SP}.}
\RU{Другими словами, \TT{STMFD} можно использовать для записи набора регистров в указанном месте памяти.}
\EN{In other words, \TT{STMFD} may be used for storing pack of registers at the specified memory address.}
\ES{En otras palabras, \TT{STMFD} puede usarse para almacenar un conjunto de registros en la dirección de memoria indicada.}

\index{\PICcode}
\index{ARM!\Instructions!ADR}
\RU{Инструкция}\EN{The}\ES{La} \TT{ADR R0, aHelloWorld}
\RU{прибавляет или отнимает значение регистра \ac{PC} к смещению, где хранится строка}
\EN{instruction adds or subtracts the value in the \ac{PC} register to the offset where the}
\TT{hello, world}\EN{ string is located}\ES{ instrucción suma o resta el valor de \ac{PC} al desplazamiento donde está la cadena}.
\RU{Причем здесь \ac{PC}, можно спросить}\EN{How is the \TT{PC} register used here, one might ask}?\ES{¿Cómo se usa aquí \ac{PC}?}
\RU{Притом, что это так называемый \q{\PICcode}}\EN{This is so-called \q{\PICcode}.}\ES{Se trata del llamado \q{\PICcode}.}
\footnote{
	\RU{Читайте больше об этом в соответствующем разделе}
	\EN{Read more about it in relevant section}\ES{Lee más sobre esto en la sección correspondiente}~(\myref{sec:PIC})
	}
\RU{он предназначен для исполнения будучи не привязанным к каким-либо адресам в памяти}%
\EN{Such code can be be executed at a non-fixed address in memory}\ES{Este código puede ejecutarse en una dirección no fija de memoria}.
\EN{In other words, this is \ac{PC}-relative addressing.}
\RU{Другими словами, это относительная от \ac{PC} адресация.}
\ES{En otras palabras, es direccionamiento relativo al \ac{PC}.}
\RU{В опкоде инструкции \TT{ADR} указывается разница между адресом этой инструкции и местом, где хранится строка}%
\EN{The \TT{ADR} instruction takes into account the difference between the address of this instruction and the address where the string is located}.\ES{El op\-code de \TT{ADR} codifica la diferencia entre la dirección de esta instrucción y el lugar donde está la cadena}.
\RU{Эта разница всегда будет постоянной, вне зависимости от того, куда был загружен \ac{OS} наш код}%
\EN{This difference (offset) is always to be the same, no matter at what address our code is loaded by the \ac{OS}}\ES{Esta diferencia (desplazamiento) siempre será la misma, independientemente de la dirección a la que el \ac{OS} cargue nuestro código}.
\RU{Поэтому всё, что нужно~--- это прибавить адрес текущей инструкции (из \ac{PC}), чтобы получить текущий абсолютный адрес нашей Си-строки}%
\EN{That's why all we need is to add the address of the current instruction (from \ac{PC}) in order to get the absolute memory address of our C-string}\ES{Por eso, lo único necesario es sumar la dirección de la instrucción actual (desde \ac{PC}) para obtener la dirección absoluta de nuestra cadena en C}.

\index{ARM!\Registers!Link Register}
\index{ARM!\Instructions!BL}
\RU{Инструкция} \TT{BL \_\_2printf}\footnote{Branch with Link}
\RU{вызывает функцию \printf}\EN{instruction calls the \printf function}. \ES{llama a la función \printf}. 
\RU{Работа этой инструкции состоит из двух фаз}%
\EN{Here's how this instruction works}\ES{Así es como funciona esta instrucción}: 
\begin{itemize}
\item
\RU{записать адрес после инструкции \TT{BL} (\TT{0xC}) в регистр \ac{LR}}%
\EN{store the address following the \TT{BL} instruction (\TT{0xC}) into the \ac{LR}}\ES{guardar la dirección siguiente a \TT{BL} (\TT{0xC}) en \ac{LR}};
\item
\RU{передать управление в \printf, записав адрес этой функции в регистр \ac{PC}}%
\EN{then pass the control to the \printf by writing its address into the \ac{PC} register}\ES{luego transferir el control a \printf escribiendo su dirección en el registro \ac{PC}}.
\end{itemize}

\RU{Ведь когда функция \printf закончит работу, нужно знать, куда вернуть управление, поэтому закончив работу, всякая функция передает управление по адресу, записанному в регистре \ac{LR}}%
\EN{When \printf finishes its execution it must have information about where it needs to return the control to.
That's why each function passes control to the address stored in the \ac{LR} register}\ES{Cuando \printf termina debe saber adónde volver; por eso toda función devuelve el control a la dirección guardada en \ac{LR}}.

\RU{В этом разница между \q{чистыми} \ac{RISC}-процессорами вроде ARM и \ac{CISC}-процессорами как x86,
где адрес возврата обычно записывается в стек}%
\EN{That is a difference between \q{pure} \ac{RISC}-processors like ARM and \ac{CISC}-processors like x86,
where the return address is usually stored on the stack}\footnote{\RU{Подробнее об этом будет описано в следующей главе}\EN{Read more about this in next section}\ES{Lee más sobre esto en la siguiente sección}~(\myref{sec:stack})}.

\RU{Кстати, 32-битный абсолютный адрес (либо смещение) невозможно закодировать в 32-битной инструкции \TT{BL}, в ней есть место только для 24-х бит}%
\EN{By the way, an absolute 32-bit address or offset cannot be encoded in the 32-bit \TT{BL} instruction because
it only has space for 24 bits}.\ES{Por cierto, una dirección absoluta de 32 bits (o un desplazamiento) no puede codificarse en la instrucción de 32 bits \TT{BL}, porque solo hay 24 bits disponibles}.
\RU{Поскольку все инструкции в режиме ARM имеют длину 4 байта (32 бита) и инструкции могут находится только по адресам кратным 4, то последние 2 бита (всегда нулевых) можно не кодировать.}
\EN{As we may remember, all ARM-mode instructions have a size of 4 bytes (32 bits).
Hence, they can only be located on 4-byte boundary addresses.
This implies that the last 2 bits of the instruction address (which are always zero bits) may be omitted.}
\ES{Como recordamos, todas las instrucciones en modo ARM miden 4 bytes (32 bits) y solo pueden situarse en direcciones múltiplos de 4; por ello, los 2 bits bajos de la dirección (siempre a 0) no se codifican.}
\RU{В итоге имеем 26 бит, при помощи которых можно закодировать}
\EN{In summary, we have 26 bits for offset encoding. This is enough to encode} $current\_PC \pm{} \approx{}32M$.\ES{En resumen, tenemos 26 bits para codificar el desplazamiento; esto basta para} $current\_PC \pm{} \approx{}32M$.

\index{ARM!\Instructions!MOV}
\RU{Следующая инструкция}\EN{Next, the}\ES{A continuación, la} \TT{MOV R0, \#0}\footnote{MOVe}
\RU{просто записывает 0 в регистр \Reg{0}}\EN{instruction just writes 0 into the \Reg{0} register}\ES{ simplemente escribe 0 en el registro \Reg{0}}.
\RU{Ведь наша Си-функция возвращает 0, а возвращаемое значение всякая функция оставляет в \Reg{0}}%
\EN{That's because our C-function returns 0 and the return value is to be placed in the \Reg{0} register}\ES{Nuestra función en C devuelve 0 y el valor de retorno debe ponerse en \Reg{0}}.

\index{ARM!\Registers!Link Register}
\index{ARM!\Instructions!LDMFD}
\index{ARM!\Instructions!POP}
\RU{Последняя инструкция}\EN{The last instruction}\ES{La última instrucción} \TT{LDMFD SP!, {R4,PC}}\footnote{\ac{LDMFD}}\RU{~--- это инструкция, обратная}\EN{ is an inverse instruction of}\ES{ es la inversa de} \TT{STMFD}. 
\RU{Она загружает из стека (или любого другого места в памяти) значения для сохранения их в \Reg{4} и \ac{PC}, увеличивая \glslink{stack pointer}{указатель стека} \ac{SP}.}
\EN{It loads values from the stack (or any other memory place) in order to save them into \Reg{4} and \ac{PC}, and \glslink{increment}{increments} the \gls{stack pointer} \ac{SP}.}
\ES{Carga desde la pila (o cualquier otra zona de memoria) los valores para guardarlos en \Reg{4} y \ac{PC}, e \glslink{increment}{incrementa} el puntero de pila \ac{SP}.}
\RU{Здесь она работает как аналог \POP}\EN{It works like \POP here}\ES{Aquí actúa como un \POP}.\\
N.B. \RU{Самая первая инструкция \TT{STMFD} сохранила в стеке \Reg{4} и \ac{LR}, а \IT{восстанавливаются} во время исполнения \TT{LDMFD} регистры \Reg{4} и \ac{PC}}%
\EN{The very first instruction \TT{STMFD} saved the \Reg{4} and \ac{LR} registers pair on the stack, but \Reg{4} and \ac{PC} are \IT{restored} during the \TT{LDMFD} execution}\ES{La primera instrucción \TT{STMFD} guardó en la pila el par de registros \Reg{4} y \ac{LR}, pero durante \TT{LDMFD} se \IT{restauran} \Reg{4} y \ac{PC}}.

\RU{Как мы уже знаем, в регистре \ac{LR} обычно сохраняется адрес места, куда нужно всякой функции вернуть управление}%
\EN{As we already know, the address of the place where each function must return control to is usually saved in the \ac{LR} register}\ES{Como ya sabemos, en \ac{LR} suele guardarse la dirección a la que debe devolver el control cada función}.
\RU{Самая первая инструкция сохраняет это значение в стеке, потому что наша функция \main позже будет сама пользоваться этим регистром в момент вызова \printf}%
\EN{The very first instruction saves its value in the stack because the same register will be used by our
\main function when calling \printf}\ES{La primera instrucción guarda ese valor en la pila, porque nuestra función \main usará ese registro al llamar a \printf}.
\RU{А затем, в конце функции, это значение можно сразу записать прямо в \ac{PC}, таким образом, передав управление туда, откуда была вызвана наша функция}%
\EN{In the function's end, this value can be written directly to the \ac{PC} register, thus passing control to where our function was called}\ES{Al final de la función, ese valor puede escribirse directamente en \ac{PC}, devolviendo el control al lugar desde el que fue llamada}.

\RU{Так как функция \main обычно самая главная в \CCpp, управление будет возвращено в загрузчик \ac{OS}, либо куда-то в \ac{CRT} 
или что-то в этом роде.}
\EN{Since \main is usually the primary function in \CCpp,
the control will be returned to the \ac{OS} loader or to a point in a \ac{CRT},
or something like that.}
\ES{Como \main suele ser la función principal en \CCpp, el control volverá al cargador del \ac{OS}, o a algún punto del \ac{CRT}, o similar.}

\EN{All that allows to omit \TT{BX LR} instruction at the end of the function.}
\RU{Всё это позволяет избавиться от инструкции \TT{BX LR} в самом конце функции.}
\ES{Todo esto permite omitir la instrucción \TT{BX LR} al final de la función.}

\index{ARM!DCB}
\TT{DCB}\RU{~--- директива ассемблера, описывающая массивы байт или ASCII-строк, аналог директивы DB в 
x86-ассемблере}%
\EN{~is an assembly language directive defining an array of bytes or ASCII strings, akin to the DB directive 
in x86-assembly language}\ES{~es una directiva del lenguaje ensamblador que define un array de bytes o cadenas ASCII, similar a la directiva DB en ensamblador x86}.

